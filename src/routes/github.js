const express = require('express');
const { Octokit } = require('@octokit/rest');
const { pool } = require('../config/database');
const logger = require('../config/logger');

const router = express.Router();

// POST /api/github/push - Push generated code to GitHub
router.post('/push', async (req, res) => {
  const { projectId, githubToken, repoName, repoDescription, isPrivate } = req.body;

  try {
    logger.info('GitHub push request received', { projectId, repoName });

    if (!projectId || !githubToken || !repoName) {
      return res.status(400).json({
        success: false,
        error: 'projectId, githubToken, and repoName are required',
      });
    }

    // Initialize Octokit with user's token
    const octokit = new Octokit({
      auth: githubToken,
    });

    // Get authenticated user
    const { data: user } = await octokit.users.getAuthenticated();
    logger.info('GitHub user authenticated', { username: user.login });

    // Get project and files
    const projectResult = await pool.query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );

    if (projectResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Project not found',
      });
    }

    const project = projectResult.rows[0];

    const filesResult = await pool.query(
      'SELECT filename, content FROM generated_files WHERE project_id = $1',
      [projectId]
    );

    if (filesResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No generated files found',
      });
    }

    // Create repository
    logger.info('Creating GitHub repository', { repoName, owner: user.login });

    const { data: repo } = await octokit.repos.createForAuthenticatedUser({
      name: repoName,
      description: repoDescription || project.description || `Generated by Command Agent v3`,
      private: isPrivate !== false, // Default to private
      auto_init: true, // Initialize with README
    });

    logger.info('Repository created', { repoUrl: repo.html_url });

    // Get the default branch
    const { data: branch } = await octokit.repos.getBranch({
      owner: user.login,
      repo: repoName,
      branch: repo.default_branch,
    });

    const latestCommitSha = branch.commit.sha;

    // Create blobs for each file
    const blobs = await Promise.all(
      filesResult.rows.map(async (file) => {
        const { data: blob } = await octokit.git.createBlob({
          owner: user.login,
          repo: repoName,
          content: Buffer.from(file.content).toString('base64'),
          encoding: 'base64',
        });

        return {
          path: file.filename,
          mode: '100644',
          type: 'blob',
          sha: blob.sha,
        };
      })
    );

    logger.info('Blobs created', { count: blobs.length });

    // Create tree
    const { data: tree } = await octokit.git.createTree({
      owner: user.login,
      repo: repoName,
      tree: blobs,
      base_tree: latestCommitSha,
    });

    // Create commit
    const { data: commit } = await octokit.git.createCommit({
      owner: user.login,
      repo: repoName,
      message: `Initial commit - Generated by Command Agent v3\n\nProject: ${project.name}\nGenerated: ${new Date().toISOString()}`,
      tree: tree.sha,
      parents: [latestCommitSha],
    });

    // Update reference
    await octokit.git.updateRef({
      owner: user.login,
      repo: repoName,
      ref: `heads/${repo.default_branch}`,
      sha: commit.sha,
    });

    logger.info('Files pushed to GitHub', {
      repoUrl: repo.html_url,
      fileCount: blobs.length,
    });

    // Save GitHub URL to project
    await pool.query(
      'UPDATE projects SET github_url = $1, updated_at = NOW() WHERE id = $2',
      [repo.html_url, projectId]
    );

    res.json({
      success: true,
      repository: {
        name: repo.name,
        url: repo.html_url,
        owner: user.login,
        private: repo.private,
      },
      filesCount: blobs.length,
      message: 'Code successfully pushed to GitHub',
    });
  } catch (error) {
    logger.error('GitHub push failed', {
      projectId,
      error: error.message,
      stack: error.stack,
    });

    // Handle specific GitHub errors
    let errorMessage = error.message;
    if (error.status === 401) {
      errorMessage = 'Invalid GitHub token';
    } else if (error.status === 422) {
      errorMessage = 'Repository name already exists or is invalid';
    }

    res.status(error.status || 500).json({
      success: false,
      error: 'GitHub push failed',
      message: errorMessage,
    });
  }
});

module.exports = router;
